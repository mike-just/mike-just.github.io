<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>顾沉舟的个人博客</title>
    <link>https://mike-just.github.io/</link>
    <description>Recent content on 顾沉舟的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jul 2020 15:34:31 +0800</lastBuildDate>
    
	<atom:link href="https://mike-just.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>测试1</title>
      <link>https://mike-just.github.io/post/blogs/%E6%B5%8B%E8%AF%951.0/</link>
      <pubDate>Sun, 12 Jul 2020 15:34:31 +0800</pubDate>
      
      <guid>https://mike-just.github.io/post/blogs/%E6%B5%8B%E8%AF%951.0/</guid>
      <description>测试1.0正在更新中 本人QQ2540074917 </description>
    </item>
    
    <item>
      <title>111</title>
      <link>https://mike-just.github.io/post/java/111/</link>
      <pubDate>Sun, 12 Jul 2020 15:02:07 +0800</pubDate>
      
      <guid>https://mike-just.github.io/post/java/111/</guid>
      <description>作用： </description>
    </item>
    
    <item>
      <title>AOP简单描述</title>
      <link>https://mike-just.github.io/post/blogs/blog1/</link>
      <pubDate>Sun, 12 Jul 2020 09:42:44 +0800</pubDate>
      
      <guid>https://mike-just.github.io/post/blogs/blog1/</guid>
      <description>面向切面编程：基于OOP基础之上新的编程思想 指在程序运行期间，将某段代码动态切入到指定方法的指定位置进行运行的这种编程方式，面向切面编程
场景：计算器运行计算方法的时候进行日志记录 加日志记录： 1.直接编写在方法内部；不推荐，修改维护麻烦 日志记录：系统的辅助功能 业务逻辑：（核心功能） 耦合；
2.我们希望的是 业务逻辑:（核心功能）；日志模块；在核心功能运行期间，自己动态的加上 运行的时候，日志功能可以加上 可以使用动态代理来将日志代码动态的在目标方法执行前后先进行执行;
动态代理： 1.写起来难 2.jdk默认的动态代理，如果目标对象没有实现任何接口，是无法为它创建代理对象的 总结： 将某段代码（日志）动态切入（不把日志代码写死在业务逻辑方法中）到指定方法（加减乘除）的指定位置（方法的开始，结束，异常）进行运行的这种编程方式
Spring动态代理：Spring实现AOP功能，底层就是动态代理 总结：可以利用Spring一句代码都不写的去创建动态代理 实现简单，没有强制要求目标对象必须实现接口 </description>
    </item>
    
    <item>
      <title>@Autowired注解</title>
      <link>https://mike-just.github.io/post/blogs/blog/</link>
      <pubDate>Sun, 12 Jul 2020 00:00:31 +0800</pubDate>
      
      <guid>https://mike-just.github.io/post/blogs/blog/</guid>
      <description>作用： 先按照类型去容器中找到对应的组件
@Autowired private BookDao bookDao; 找到就直接赋值
没找到就报错
具体流程： 先按照类型来找。。。。
找到多个类型一样的呢？按照变量名(bookDao)作为id继续匹配
那如果变量名有一样的呢？报错。可以使用@Qualifier(&amp;ldquo;haha&amp;rdquo;)指定一个字符串作为新的id
那如果@Qualifier也找不到呢？@Autowired(required=false)表示自动装配null
如果@Autowired作用在方法上呢？
@Controller public class BookServlet { //1.这个方法也会在bean创建的时候自动运行 //2.这个方法的每一个参数都会自动注入值 } @Autowired public void haha(BookDao dao,BookService bookService){ System.out.println(&amp;#34;Spring运行了这个方法。。。&amp;#34;+dao+bookService); } 总结： @Autowired 、@Resource、@Inject;都是自动装配的意思 @Autowired :最强大： Spring的注解 @Resource：默认 byname java的标准 @Resource的扩展性强，如果我们切换成另外一个容器框架，@Resource还是可以使用的，@Autowired就不行了 </description>
    </item>
    
  </channel>
</rss>